# Anvil Form module (export of your form code)
# Save this as: anvil/capteurs_form.py
# NOTE: This file references ._anvil_designer import (CapteursTemplate) which is
# generated by the Anvil Form designer. This file is fine for review on GitHub,
# but to run the form you normally rely on the Anvil IDE's project structure.

from ._anvil_designer import CapteursTemplate
from anvil import *
import anvil.users
import anvil.server
from datetime import datetime, timedelta
import random
import plotly.graph_objects as go

class Capteurs(CapteursTemplate):

  def __init__(self, **properties):
    self.init_components(**properties)
    self.user_email = anvil.users.get_user()['email']
    self.alert_active = False
    self.average_history = []
    self.last_simul_update = datetime.now()

    # ---- Valeurs simul√©es suivies/initialis√©es d√®s le d√©part ----
    reelles = anvil.server.call('obtenir_dernieres_donnees')
    if reelles["capteur1"] and reelles["capteur2"]:
      temp_avg = (reelles["capteur1"]["temp"] + reelles["capteur2"]["temp"]) / 2
      hum_avg = (reelles["capteur1"]["humid"] + reelles["capteur2"]["humid"]) / 2
      self.sensor_values = {
        f"sensor_{i+1}": {
          "temp": temp_avg + random.uniform(-0.3, 0.3),
          "hum": hum_avg + random.uniform(-1, 1)
        }
        for i in range(10)
      }
    else:
      self.sensor_values = {
        f"sensor_{i+1}": {"temp": random.uniform(25, 30), "hum": random.uniform(20, 50)}
        for i in range(10)
      }

    self.init_heatmaps()
    for i in range(10):
      getattr(self, f"temp_{i+1}").text = f"{self.sensor_values[f'sensor_{i+1}']['temp']:.1f}"
      getattr(self, f"hum_{i+1}").text = f"{self.sensor_values[f'sensor_{i+1}']['hum']:.1f}"
    self.update_heatmaps()

    # üëâ Charger la DataGrid ici au d√©marrage
    try:
      self.repeating_panel_capteurs.items = anvil.server.call('get_all_capteur_rows', 100)
    except Exception as e:
      print(f"‚ùå Erreur chargement DataGrid: {e}")

      # === Affiche les valeurs r√©elles √† l'initialisation ===
    self.display_actual_physical_sensor_data()

    self.update_timer.enabled = True

  def init_heatmaps(self):
    self.temp_heat_boxes = []
    self.hum_heat_boxes = []
    self.temp_heatmap_panel.clear()
    self.hum_heatmap_panel.clear()
    for row in range(2):
      temp_row_panel = FlowPanel(spacing="small")
      hum_row_panel = FlowPanel(spacing="small")
      for col in range(5):
        idx = row * 5 + col
        temp_box = Label(
          text=f"Capteur {idx+1}",
          align='center',
          background="lightgreen",
          foreground="black",
          border="1px solid #ccc"
        )
        hum_box = Label(
          text=f"Capteur {idx+1}",
          align='center',
          background="lightgreen",
          foreground="black",
          border="1px solid #ccc"
        )
        temp_box.width = 90
        temp_box.height = 30
        hum_box.width = 90
        hum_box.height = 30
        self.temp_heat_boxes.append(temp_box)
        self.hum_heat_boxes.append(hum_box)
        temp_row_panel.add_component(temp_box)
        hum_row_panel.add_component(hum_box)
      self.temp_heatmap_panel.add_component(temp_row_panel)
      self.hum_heatmap_panel.add_component(hum_row_panel)

  def update_heatmaps(self):
    limits = anvil.server.call("get_live_sensor_limits")
    min_temp, max_temp = limits["min_temp"], limits["max_temp"]
    min_hum, max_hum = limits["min_hum"], limits["max_hum"]
    out_of_range_sensors = []
    for i in range(10):
      temp_box = getattr(self, f"temp_{i+1}")
      hum_box = getattr(self, f"hum_{i+1}")
      try:
        temp = float(temp_box.text)
      except (ValueError, TypeError):
        temp = self.sensor_values[f"sensor_{i+1}"]["temp"]
      try:
        hum = float(hum_box.text)
      except (ValueError, TypeError):
        hum = self.sensor_values[f"sensor_{i+1}"]["hum"]
      if temp < min_temp - 0.5 or temp > max_temp + 0.5:
        temp_box.background = "darkred"
      elif temp < min_temp or temp > max_temp:
        temp_box.background = "lightcoral"
      elif (min_temp <= temp < min_temp + 0.5) or (max_temp - 0.5 < temp <= max_temp):
        temp_box.background = "orange"
      else:
        temp_box.background = "lightgreen"
      if hum < min_hum - 2 or hum > max_hum + 2:
        hum_box.background = "darkred"
      elif hum < min_hum or hum > max_hum:
        hum_box.background = "lightcoral"
      elif (min_hum <= hum < min_hum + 2) or (max_hum - 2 < hum <= max_hum):
        hum_box.background = "orange"
      else:
        hum_box.background = "lightgreen"
      temp_out = temp < min_temp or temp > max_temp
      hum_out = hum < min_hum or hum > max_hum
      if temp_out or hum_out:
        out_of_range_sensors.append({
          "sensor": f"Sensor {i+1}",
          "temp": temp,
          "hum": hum
        })
      self.temp_heat_boxes[i].background = temp_box.background
      self.hum_heat_boxes[i].background = hum_box.background
      self.temp_heat_boxes[i].text = f"Sensor {i+1}"
      self.hum_heat_boxes[i].text = f"Sensor {i+1}"
    if out_of_range_sensors and not self.alert_active:
      lines = ["Les capteurs suivants sont hors du seuil s√©lectionn√©:\n"]
      for s in out_of_range_sensors:
        lines.append(f"‚Ä¢ {s['sensor']} ‚Äî Temp√©rature: {s['temp']}¬∞C, Humidit√©: {s['hum']}%")
      body = "\n".join(lines)
      anvil.server.call("send_summary_alert", self.user_email, body)
      self.alert_active = True
    elif not out_of_range_sensors and self.alert_active:
      self.alert_active = False
    temps = [float(getattr(self, f"temp_{i+1}").text) for i in range(10)]
    hums = [float(getattr(self, f"hum_{i+1}").text) for i in range(10)]
    self.avg_temp_box.text = round(sum(temps)/len(temps), 2)
    self.avg_hum_box.text = round(sum(hums)/len(hums), 2)

  def display_actual_physical_sensor_data(self):
    # Affiche les valeurs capteur physique sur des labels d√©di√©s
    reelles = anvil.server.call('obtenir_dernieres_donnees')
    # Capteur 1
    r1 = reelles.get("capteur1")
    if r1:
      self.label_temp_reel_1.text = f"{r1['temp']:.1f} ¬∞C"
      self.label_hum_reel_1.text = f"{r1['humid']:.1f} %"
    else:
      self.label_temp_reel_1.text = "?"
      self.label_hum_reel_1.text = "?"
      # Capteur 2
    r2 = reelles.get("capteur2")
    if r2:
      self.label_temp_reel_2.text = f"{r2['temp']:.1f} ¬∞C"
      self.label_hum_reel_2.text = f"{r2['humid']:.1f} %"
    else:
      self.label_temp_reel_2.text = "?"
      self.label_hum_reel_2.text = "?"

  def update_timer_tick(self, **event_args):
    now = datetime.now()
    # --- Actualise les capteurs simul√©s toutes les 30 secondes ---
    if (now - self.last_simul_update).total_seconds() >= 30:
      reelles = anvil.server.call('obtenir_dernieres_donnees')
      if reelles["capteur1"] and reelles["capteur2"]:
        temp_avg = (reelles["capteur1"]["temp"] + reelles["capteur2"]["temp"]) / 2
        hum_avg = (reelles["capteur1"]["humid"] + reelles["capteur2"]["humid"]) / 2
        for i in range(10):
          temp = round(temp_avg + random.uniform(-0.3, 0.3), 1)
          hum = round(hum_avg + random.uniform(-1, 1), 1)
          self.sensor_values[f"sensor_{i+1}"]["temp"] = temp
          self.sensor_values[f"sensor_{i+1}"]["hum"] = hum
          getattr(self, f"temp_{i+1}").text = f"{temp:.1f}"
          getattr(self, f"hum_{i+1}").text = f"{hum:.1f}"
      else:
        for i in range(10):
          temp = round(self.sensor_values[f"sensor_{i+1}"]["temp"] + random.uniform(-0.5, 0.5), 1)
          hum = round(self.sensor_values[f"sensor_{i+1}"]["hum"] + random.uniform(-2, 2), 1)
          self.sensor_values[f"sensor_{i+1}"]["temp"] = temp
          self.sensor_values[f"sensor_{i+1}"]["hum"] = hum
          getattr(self, f"temp_{i+1}").text = f"{temp:.1f}"
          getattr(self, f"hum_{i+1}").text = f"{hum:.1f}"
      self.last_simul_update = now

    self.update_heatmaps()

    # --- Recharge la DataGrid toutes les 10 sec, comme avant ---
    try:
      self.repeating_panel_capteurs.items = anvil.server.call('get_all_capteur_rows', 100)
    except Exception as e:
      print(f"‚ùå Erreur chargement DataGrid: {e}")

    temps = [v["temp"] for v in self.sensor_values.values()]
    hums = [v["hum"] for v in self.sensor_values.values()]
    avg_temp = sum(temps)/len(temps)
    avg_hum = sum(hums)/len(hums)
    self.average_history.append({"time": datetime.now(), "avg_temp": avg_temp, "avg_hum": avg_hum})
    if len(self.average_history) > 50:
      self.average_history = self.average_history[-50:]
    times = [d["time"] for d in self.average_history]
    temps = [d["avg_temp"] for d in self.average_history]
    hums = [d["avg_hum"] for d in self.average_history]
    times_ms = [int(t.timestamp()*1000) for t in times]
    self.averages_plot.data = [
      go.Scatter(x=times_ms, y=temps, name="Temp√©rature moyenne (¬∞C)", mode="lines+markers", line={"color": "red"}),
      go.Scatter(x=times_ms, y=hums, name="Humidit√© moyenne (%)", mode="lines+markers", line={"color": "blue"}, yaxis="y2")
    ]
    tick_indices = list(range(0, len(times_ms), max(1, len(times_ms)//5))) + [len(times_ms)-1]
    tickvals = [times_ms[i] for i in tick_indices]
    ticktext = [times[i].strftime("%H:%M:%S") for i in tick_indices]
    self.averages_plot.layout = {
      "xaxis": {"title": "Time", "type": "date", "tickvals": tickvals, "ticktext": ticktext},
      "yaxis": {"title": "Temp√©rature (¬∞C)", "range": [0, 40]},
      "yaxis2": {"title": "Humidit√© (%)", "overlaying": "y", "side": "right", "range": [0, 70]},
      "title": "Moyennes de Temp√©rature et Humidit√© selon le temps",
      "margin": {"l": 50, "r": 50, "t": 50, "b": 50}
    }

    # === Mise √† jour dynamique des labels de valeurs r√©elles ===
    self.display_actual_physical_sensor_data()
